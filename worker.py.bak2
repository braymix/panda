#!/usr/bin/env python3
"""
PANDA Worker v3.1 - Pana Automating Never Death (on) Afterwork

- Auto-fix risposte Ollama (rimuove "python", "bash", ecc.)
- Scrive stato task corrente per dashboard
- Retry automatico su fallimento (con _retry_count nel task)
- Supporto stop pipeline su fail:
  - stop_on_test_fail (config) per task di tipo test
  - stop_on_fail (per-task) per qualsiasi tipo
- Log migliorati
"""

import json
import os
import sys
import time
import subprocess
import requests
from datetime import datetime
from pathlib import Path

PANDA_HOME = Path.home() / "panda"
TASKS_DIR = PANDA_HOME / "tasks"
RESULTS_DIR = PANDA_HOME / "results"
LOGS_DIR = PANDA_HOME / "logs"
STATUS_DIR = PANDA_HOME / "status"
CONFIG_FILE = PANDA_HOME / "config" / "panda.json"
CURRENT_STATUS_FILE = STATUS_DIR / "current.json"

DEFAULT_CONFIG = {
    "ollama_url": "http://localhost:11434",
    "model": "qwen2.5-coder:3b",
    "check_interval": 10,
    "max_retries": 3,
    "execute_code": True,
    "execute_bash": True,
    "modify_files": True,

    # v3.1
    "stop_on_test_fail": False   # se True: fallimento di un task test ferma la pipeline
}

def log(message, level="INFO"):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"[{timestamp}] [{level}] {message}"
    print(log_line, flush=True)
    log_file = LOGS_DIR / f"{datetime.now().strftime('%Y-%m-%d')}.log"
    with open(log_file, "a") as f:
        f.write(log_line + "\n")

def update_status(task_id=None, task_type=None, status="idle", progress=None):
    """Aggiorna stato corrente per la dashboard"""
    STATUS_DIR.mkdir(exist_ok=True)
    state = {
        "current_task": task_id,
        "task_type": task_type,
        "status": status,
        "progress": progress,
        "updated_at": datetime.now().isoformat()
    }
    with open(CURRENT_STATUS_FILE, "w") as f:
        json.dump(state, f)

def load_config():
    if CONFIG_FILE.exists():
        with open(CONFIG_FILE) as f:
            return {**DEFAULT_CONFIG, **json.load(f)}
    return DEFAULT_CONFIG

def save_default_config():
    if not CONFIG_FILE.exists():
        CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_CONFIG, f, indent=2)

def ask_ollama(prompt, config):
    url = f"{config['ollama_url']}/api/generate"
    payload = {"model": config["model"], "prompt": prompt, "stream": False}
    try:
        response = requests.post(url, json=payload, timeout=900)
        response.raise_for_status()
        return response.json().get("response", "")
    except Exception as e:
        log(f"Errore Ollama: {e}", "ERROR")
        return None

def clean_code_response(code, language=""):
    """
    Pulisce la risposta di Ollama:
    - Rimuove prima riga se √® solo "python", "bash", "html", ecc.
    - Rimuove blocchi markdown ```
    - Rimuove spazi extra
    """
    if not code:
        return code

    code = code.strip()
    lines = code.split('\n')

    junk_first_lines = ['python', 'bash', 'sh', 'html', 'css', 'javascript', 'js', 'json', 'sql', 'yaml', 'xml']
    if lines and lines[0].strip().lower() in junk_first_lines:
        lines = lines[1:]
        code = '\n'.join(lines)

    code = code.strip()
    markers = [f"```{language}", "```python", "```bash", "```sh", "```html", "```css", "```javascript", "```js", "```json", "```"]
    for marker in markers:
        if code.startswith(marker):
            code = code[len(marker):]
            break
    if code.endswith("```"):
        code = code[:-3]

    lines = code.strip().split('\n')
    if lines and lines[0].strip().lower() in junk_first_lines:
        lines = lines[1:]
        code = '\n'.join(lines)

    return code.strip()

def execute_bash(command):
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=300)
        return {"success": result.returncode == 0, "stdout": result.stdout, "stderr": result.stderr, "returncode": result.returncode}
    except subprocess.TimeoutExpired:
        return {"success": False, "error": "Timeout"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def execute_python(code):
    try:
        temp_file = PANDA_HOME / "scripts" / f"temp_{int(time.time())}.py"
        temp_file.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_file, "w") as f:
            f.write(code)
        result = subprocess.run([sys.executable, str(temp_file)], capture_output=True, text=True, timeout=300, cwd=str(PANDA_HOME))
        return {"success": result.returncode == 0, "stdout": result.stdout, "stderr": result.stderr, "returncode": result.returncode}
    except Exception as e:
        return {"success": False, "error": str(e)}

def write_file(filepath, content):
    try:
        path = Path(filepath).expanduser()
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            f.write(content)
        return {"success": True, "path": str(path)}
    except Exception as e:
        return {"success": False, "error": str(e)}

def get_prompt(task):
    if "prompt_file" in task:
        prompt_path = task["prompt_file"]
        if not str(prompt_path).startswith("/") and not str(prompt_path).startswith("~"):
            prompt_path = TASKS_DIR / prompt_path
        else:
            prompt_path = Path(prompt_path).expanduser()
        try:
            with open(prompt_path, "r") as f:
                return f.read().strip()
        except Exception as e:
            log(f"Errore lettura prompt_file {prompt_path}: {e}", "ERROR")
            return None
    return task.get("prompt", "")

def should_stop_pipeline(task, task_type, success, config):
    """Regole di stop pipeline v3.1"""
    if success:
        return False
    if bool(task.get("stop_on_fail", False)):
        return True
    if task_type == "test" and bool(config.get("stop_on_test_fail", False)):
        return True
    return False

def handle_retry(task_file: Path, task: dict, task_id: str, success: bool, config: dict) -> bool:
    """
    Se fallisce e ci sono retry disponibili:
    - incrementa _retry_count
    - riscrive il task file
    - NON lo sposta in done
    Ritorna True se ha schedulato retry (quindi il task non √® 'concluso').
    """
    if success:
        return False

    retry_count = int(task.get("_retry_count", 0))
    max_retries = int(config.get("max_retries", 3))

    if retry_count < max_retries:
        task["_retry_count"] = retry_count + 1
        try:
            with open(task_file, "w") as f:
                json.dump(task, f, indent=2)
            log(f"üîÅ Retry schedulato per {task_id} ({task['_retry_count']}/{max_retries})", "WARN")
            return True
        except Exception as e:
            log(f"Errore nel salvare retry per {task_id}: {e}", "ERROR")
            return False

    return False

def finalize_task(task_file: Path, task: dict, task_id: str, result: dict):
    """Salva result + sposta task e prompt_file in done"""
    RESULTS_DIR.mkdir(exist_ok=True)
    result_file = RESULTS_DIR / f"{task_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(result_file, "w") as f:
        json.dump(result, f, indent=2, default=str)

    done_dir = TASKS_DIR / "done"
    done_dir.mkdir(exist_ok=True)
    task_file.rename(done_dir / task_file.name)

    if "prompt_file" in task:
        pf = task["prompt_file"]
        pf_path = (TASKS_DIR / pf) if (not str(pf).startswith("/") and not str(pf).startswith("~")) else Path(pf).expanduser()
        if pf_path.exists():
            try:
                pf_path.rename(done_dir / pf_path.name)
            except Exception:
                pass

def process_task(task_file: Path, config: dict):
    """
    Ritorna dict:
    - success: bool
    - stop: bool   (stop pipeline)
    - retried: bool (task lasciato in coda con retry incrementato)
    """
    log(f"‚ñ∂ Processo task: {task_file.name}")

    try:
        with open(task_file) as f:
            task = json.load(f)
    except Exception as e:
        log(f"Errore lettura task: {e}", "ERROR")
        return {"success": False, "stop": False, "retried": False}

    task_id = task.get("id", task_file.stem)
    task_type = task.get("type", "prompt")
    prompt = get_prompt(task)

    if prompt is None:
        log(f"Impossibile ottenere prompt per task {task_id}", "ERROR")
        return {"success": False, "stop": False, "retried": False}

    update_status(task_id, task_type, "running", "Elaborazione in corso...")

    result = {
        "task_id": task_id,
        "task": task,
        "prompt_preview": prompt[:200] + "..." if len(prompt) > 200 else prompt,
        "started_at": datetime.now().isoformat(),
        "steps": []
    }

    success = False

    if task_type == "prompt":
        log(f"  üìù Invio prompt a Ollama...")
        update_status(task_id, task_type, "running", "Attendo risposta Ollama...")
        response = ask_ollama(prompt, config)
        if response:
            result["steps"].append({"type": "ollama", "response": response})
            success = True
        else:
            result["error"] = "Ollama non ha risposto"

    elif task_type == "bash":
        if not config["execute_bash"]:
            result["error"] = "bash execution disabled"
        else:
            log(f"  üñ•Ô∏è Chiedo comando bash a Ollama...")
            update_status(task_id, task_type, "running", "Genero comando bash...")
            llm_prompt = (
                "Genera SOLO il comando bash. Rispondi SOLO con il comando, senza spiegazioni, senza markdown, senza ```.\n\n"
                f"Task: {prompt}\n\nComando:"
            )
            command = ask_ollama(llm_prompt, config)
            if command:
                command = clean_code_response(command, "bash")
                for line in command.split('\n'):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        command = line
                        break
                log(f"  ‚ñ∂ Eseguo: {command}")
                update_status(task_id, task_type, "running", f"Eseguo: {command[:50]}...")
                exec_result = execute_bash(command)
                result["steps"].append({"type": "bash", "command": command, "result": exec_result})
                success = exec_result["success"]
                if not success:
                    log(f"  ‚ùå Errore: {exec_result.get('stderr', exec_result.get('error', 'unknown'))}", "ERROR")

    elif task_type == "python":
        if not config["execute_code"]:
            result["error"] = "code execution disabled"
        else:
            log(f"  üêç Chiedo codice Python a Ollama...")
            update_status(task_id, task_type, "running", "Genero codice Python...")
            llm_prompt = f"Genera SOLO codice Python. Niente spiegazioni, niente markdown.\n\nTask: {prompt}\n\nCodice:"
            code = ask_ollama(llm_prompt, config)
            if code:
                code = clean_code_response(code, "python")
                log(f"  ‚ñ∂ Eseguo Python ({len(code)} chars)")
                update_status(task_id, task_type, "running", "Eseguo codice Python...")
                exec_result = execute_python(code)
                result["steps"].append({"type": "python", "code": code, "result": exec_result})
                success = exec_result["success"]
                if not success:
                    log(f"  ‚ùå Errore: {exec_result.get('stderr', exec_result.get('error', 'unknown'))}", "ERROR")

    elif task_type == "file":
        if not config["modify_files"]:
            result["error"] = "file modification disabled"
        else:
            filepath = task.get("filepath", "")
            if not filepath:
                result["error"] = "filepath mancante"
            else:
                log(f"  üìÑ Genero contenuto per {filepath}...")
                update_status(task_id, task_type, "running", f"Genero {Path(filepath).name}...")
                llm_prompt = f"Genera SOLO il contenuto del file. Niente spiegazioni, niente markdown ```.\n\nTask: {prompt}\n\nContenuto:"
                content = ask_ollama(llm_prompt, config)
                if content:
                    content = clean_code_response(content, "")
                    log(f"  üíæ Scrivo {filepath} ({len(content)} chars)")
                    update_status(task_id, task_type, "running", f"Scrivo {Path(filepath).name}...")
                    write_result = write_file(filepath, content)
                    result["steps"].append({"type": "file", "filepath": filepath, "size": len(content), "result": write_result})
                    success = write_result["success"]

    elif task_type == "multi":
        steps = task.get("steps", [])
        success = True
        for i, step in enumerate(steps):
            log(f"  üìå Step {i+1}/{len(steps)}")
            update_status(task_id, task_type, "running", f"Step {i+1}/{len(steps)}")
            step_task = {"id": f"{task_id}_step{i}", **step}
            step_file = TASKS_DIR / f"_temp_step_{i}.json"
            with open(step_file, "w") as f:
                json.dump(step_task, f, indent=2)
            step_res = process_task(step_file, config)
            step_file.unlink(missing_ok=True)
            if not step_res.get("success", False):
                success = False
                break

    elif task_type == "test":
        log(f"  üß™ Eseguo test: {task.get('test_name', 'unknown')}")
        update_status(task_id, task_type, "running", "Eseguo test...")
        test_command = task.get("test_command", "")
        expected = task.get("expected", "")
        if test_command:
            exec_result = execute_bash(test_command)
            actual = exec_result.get("stdout", "").strip()
            passed = (expected in actual) if expected else exec_result.get("success", False)
            result["steps"].append({
                "type": "test",
                "command": test_command,
                "expected": expected,
                "actual": actual,
                "passed": passed
            })
            success = bool(passed)
            log(f"  {'‚úÖ' if passed else '‚ùå'} Test {'PASSED' if passed else 'FAILED'}")

    else:
        log(f"Tipo task sconosciuto: {task_type}", "ERROR")
        result["error"] = f"unknown task type: {task_type}"

    # Chiudi result
    result["success"] = success
    result["finished_at"] = datetime.now().isoformat()

    # Decidi stop pipeline
    stop_pipeline = should_stop_pipeline(task, task_type, success, config)
    if stop_pipeline:
        result["stop_pipeline"] = True

    # Retry?
    retried = handle_retry(task_file, task, task_id, success, config)
    if retried:
        # salva result comunque (cos√¨ vedi gli errori) ma non spostare task in done
        RESULTS_DIR.mkdir(exist_ok=True)
        result_file = RESULTS_DIR / f"{task_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(result_file, "w") as f:
            json.dump(result, f, indent=2, default=str)

        update_status(None, None, "idle")
        status_emoji = "üîÅ"
        log(f"{status_emoji} Task {task_id}: retry programmato")
        return {"success": False, "stop": stop_pipeline, "retried": True}

    # Task concluso (success o fail definitivo)
    finalize_task(task_file, task, task_id, result)

    update_status(None, None, "idle")
    status_emoji = "‚úÖ" if success else "‚ùå"
    log(f"{status_emoji} Task {task_id} completato: {'OK' if success else 'FALLITO'}")

    return {"success": success, "stop": stop_pipeline, "retried": False}

def get_pending_tasks():
    tasks = []
    for f in TASKS_DIR.glob("*.json"):
        if f.name.startswith("_"):
            continue
        try:
            with open(f) as file:
                data = json.load(file)
                priority = data.get("priority", 10)
                tasks.append((priority, f))
        except Exception:
            tasks.append((10, f))
    tasks.sort(key=lambda x: x[0])
    return [t[1] for t in tasks]

def main():
    log("=" * 60)
    log("üêº PANDA Worker v3.1 avviato!")
    log("=" * 60)
    log(f"üìÅ Home: {PANDA_HOME}")
    log("‚ú® Features: auto-fix, stato live, retry, test, pipeline-stop")
    log("")

    LOGS_DIR.mkdir(exist_ok=True)
    RESULTS_DIR.mkdir(exist_ok=True)
    STATUS_DIR.mkdir(exist_ok=True)
    save_default_config()
    update_status(None, None, "idle")

    while True:
        try:
            config = load_config()
            pending = get_pending_tasks()

            if pending:
                log(f"üìã Trovati {len(pending)} task pendenti")
                for task_file in pending:
                    res = process_task(task_file, config)
                    config = load_config()  # Hot reload

                    if res.get("stop"):
                        log("üõë STOP pipeline: task fallito bloccante", "WARN")
                        break

            time.sleep(config["check_interval"])

        except KeyboardInterrupt:
            log("üêº PANDA Worker fermato")
            update_status(None, None, "stopped")
            break
        except Exception as e:
            log(f"Errore loop principale: {e}", "ERROR")
            time.sleep(30)

if __name__ == "__main__":
    main()
